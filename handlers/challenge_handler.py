#!/usr/bin/env python3

import shlex
import pickle
import re
from helpers.command import *
from helpers.invalid_command import *
from helpers.ctf import *
from helpers.challenge import *
from unidecode import unidecode

class AddCTFCommand(Command):
  """
    Add and keep track of a new CTF
  """

  def __init__(self, args, purpose, database):
    if len(args) < 1:
      raise InvalidCommand("Usage : add ctf <ctf_name>")

    self.name = args[0]
    self.purpose = purpose
    self.database = database

  def execute(self, slack_client):
    response = slack_client.api_call("channels.create",
        name=self.name, validate=False)

    if response['ok'] == False:
      raise InvalidCommand("\"%s\" channel creation failed.\nError : %s" % (self.name, response['error']))

    channel_id = response['channel']['id']
    response = slack_client.api_call("channels.setPurpose",
        purpose=self.purpose, channel=channel_id)

    # New CTF object
    ctf = CTF(channel_id, self.name)

    # Update list of CTFs
    ctfs = pickle.load(open(self.database, "rb"))
    ctfs.append(ctf)
    pickle.dump(ctfs, open(self.database, "wb"))

class AddChallengeCommand(Command):
  """
    Add and keep track of a new challenge for a given CTF
  """

  def __init__(self, args, channel):
    if len(args) < 1:
      raise InvalidCommand("Usage : add challenge <challenge_name>")

    self.challenge = args[0]
    self.ctf = channel
    self.channel = "%s-%s" % (self.ctf, self.challenge)

  def execute(self, slack_client):
    response = slack_client.api_call("channels.create",
        name=self.channel, validate=False)

    if response['ok'] == False:
      raise InvalidCommand("\"%s\" channel creation failed.\nError : %s" % (self.channel, response['error']))

class StatusCommand(Command):
  """
    Get a status of the currently running CTFs
  """

  def __init__(self, channel, database):
    self.database = database
    self.channel = channel

  def execute(self, slack_client):
    ctfs = pickle.load(open(self.database, "rb"))

    response = ""
    for ctf in ctfs:
      response += "*=== %s ===*\n" % ctf.name

    response = response.strip()
    slack_client.api_call("chat.postMessage",
        channel=self.channel, text=response)

class ChallengeHandler:
  """
    Manages everything related to challenge coordination.

    Commands :
    # Create a defcon-25-quals channel
    @ota_bot add ctf "defcon 25 quals"

    # Create a web-100 channel
    @ota_bot add challenge "web 100" "defcon 25 quals"

    # Kick member from other ctf challenge channels and invite the member to the web 100 channel
    @ota_bot working "web 100"

    # Get status of all CTFs
    @ota_bot status
  """

  DB = "databases/challenge_handler.bin"
  CTF_PURPOSE = "CTF=DO_NOT_DELETE_THIS=CTF"
  CHALL_PURPOSE = "CHALL=(.+?)=CHALL"

  def __init__(self, slack_client):

    # Find channels generated by challenge_handler
    database = []
    response = slack_client.api_call("channels.list")

    # Find active CTF channels
    for channel in response['channels']:
      purpose = channel['purpose']['value']

      if not channel['is_archived'] and re.match(self.CTF_PURPOSE, purpose):
        ctf = CTF(channel['id'], channel['name'])
        database.append(ctf)

    pickle.dump(database, open(self.DB, "wb+"))
    self.slack_client = slack_client

  def process(self, command, channel):
    command_line = unidecode(command.lower())
    args = shlex.split(command_line)
    command = None

    try:
      # Add CTF command
      if args[:2] == ["add", "ctf"]:
        command = AddCTFCommand(args[2:], self.CTF_PURPOSE, self.DB)

      # Add challenge command
      elif args[:2] == ["add", "challenge"]:
        command = AddChallengeCommand(args[2:], channel)

      # Working command
      elif args[:1] == ["working"]:
        command = WorkingCommand(args[1:])

      elif args[:1] == ["status"]:
        command = StatusCommand(channel, self.DB)

      if command:
        command.execute(self.slack_client)

    except InvalidCommand as e:
      self.slack_client.api_call("chat.postMessage",
        channel=channel, text=e.message)

